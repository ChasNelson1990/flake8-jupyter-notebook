#!/usr/bin/env node
// -*- mode: ruby -*-
// vi: set ft=javascript :
const fs            = require('fs');
const child_process = require('child_process');


// Example error
// test.ipynb#In[2]:4:1: E305 expected 2 blank lines after class or function definition, found 1
const flake8_error_format = new RegExp(/^([^#]+)[^:]*:(\d+):(\d+): (\w\d+) ([\s|\w]*)/);

let has_errors = false;

let cached_processing = {};

const debug = process.env.INPUT_DEBUG === 'true';


for(let notebook_path of find_notebook_files('.')) {
  if (debug) {
    process.stdout.write(notebook_path + "\n");
  }

  let notebook_lines = fs.readFileSync(notebook_path, { encoding: 'utf8', flag: 'r' }).split("\n");
      notebook_lines.unshift(null); // this way offset lines to start at index 1

  find_source_blocks(notebook_lines).forEach(({ source_line, lines_of_code }) => {

    let block     = notebook_lines.slice(source_line, source_line + lines_of_code);
    let formatted = block.map((line) => {
      return line // remove enclosing quotes and insert true newline
        .trim()
        .replace(/^"/, '')
        .replace(/",?$/, '')
        .replace(/\\n/, "\n");
    }).join('');


    let reported_errors = child_process
      .spawnSync('flake8', ['--exit-zero', '-'], { input: formatted, encoding: 'utf8' })
      .stdout
      .split("\n");


    reported_errors.forEach((reported_error) => {
      if (debug) {
        console.log(reported_error);
      }

      let error_information = reported_error.match(flake8_error_format);
      
      if (!error_information) {
        return;
      }

      // As we pass contents to flake8 via stdin it expects them to be python files,
      // however in notebooks the last line of a code block does not end in a newline.
      // We ignore these warnings
      // W292 no newline at end of file
      if (error_information[4] === 'W292') {
        return;
      }

      let line_number   = source_line + parseInt(error_information[2], 10) - 1;
      // 4 is the indentation level of embeded source code, +1 for the quote character
      let column        = error_information[3] + 5;
      let error_message = `${error_information[4]} ${error_information[5]}`;

      process.stdout.write(
        `::error file=${notebook_path},line=${line_number},col=${column}::${error_message}\n`
      );
    });
  });
}


if (has_errors) {
  process.exit(1);
}


// HELPER FUNCTIONS
function* find_notebook_files(directory_path) {
  let directory = fs.opendirSync(directory_path);
  let entry;
  while ((entry = directory.readSync()) !== null) {
    if (entry.isFile()) {
      if (entry.name.match(/.ipynb$/)) {
        yield directory_path + '/' + entry.name;
      }
    }

    if (entry.isDirectory()) {
      if (entry.name.match(/^\.git$/)) {
        continue; // skip .git folder traversal for improved speed
      }

      yield* find_notebook_files(directory_path + '/' + entry.name);
    }
  }

  directory.close();
  return;
}

// locate within the notebook lines the source blocks, their starting
// line, and number of lines of code contained within
function find_source_blocks(lines) {
  let source_blocks = [];

  for(let i = 1; i < lines.length;) {
    let match = lines[i].match(/^\s{3}"source":/);

    if (match) {
      let count = count_source_lines(i, lines);
      source_blocks.push({
        source_line: i + 1,
        lines_of_code: count
      });
      i = i + count;
    } else {
      i++;
    }
  }

  return source_blocks;
}

function count_source_lines(source_property_line_number, content_lines) {
  let counter = 0;
  for(let i = source_property_line_number + 1; i < content_lines.length; i++) {
    let match = content_lines[i].match(/^\s{4}"/);
    if (match) {
      counter++;
    } else {
      break;
    }
  }

  return counter;
}


